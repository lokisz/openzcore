/*
 * File:        pippo_except.v
 * Project:     pippo
 * Designer:    kiss@pwrsemi
 * Mainteiner:  kiss@pwrsemi
 * Checker:
 * Assigner:    
 * Description:
    一，PWR架构中断定义，描述和分类
        An interrupt is the action in which the processor saves its old context (MSR and instruction pointer) 
        and begins execution at a pre-determined interrupt-handler address, with a modified MSR. Exceptions 
        are events which, if enabled, cause the processor to take an interrupt. Exceptions are generated by 
        signals from internal and external peripherals, instructions, internal timer facilities, debug events, 
        or error conditions.
        PWR架构中断分类类型：Maskable/non-maskable, precise/imprecise, synchronous/asynchronous
            精确中断发生时，指令计数器指向引发中断指令或者下一条顺序指令。非精确中断的指令计数器可能指向别处，
            从而不能保证软件可复原现场。注意：Precise和Imprecise是在非屏蔽（non-masked）情况下中断发生时定义
            的。[TBD：masked情况下处理逻辑]。
            异步中断的产生独立于指令的执行，所有异步中断都是精确中断；同步中断由于指令的执行（或尝试执行）引
            发，同步中断可能是精确中断，也可能是非精确中断。引发异步中断的指令可能已经还未开始执行，或者部分
            完成；引发同步精确中断的指令则可能已经开始执行（除引发中断），也可能部分完成，或者完成，取决于中
            断类型。
            Machine check中断是PWR架构的一种特别中断，它由硬件或存储系统的错误引发，或者是尝试访问invalid地
            址。在处理器检测和报告MC中断前，引起的指令可能已经完成，并且处理器沿着后续路径已经执行多条指令。
    二，pippo实现            
        All interrupts, except for machine checks, are handled precisely. Precise handling implies that the 
        address of the excepting instruction (for synchronous exceptions other than the system call exception),
        or the address of the next instruction to be executed (asynchronous exceptions and the system call 
        exception), is passed to an interrupt handling routine. 
        Synchronous precise interrupts include most debug event interrupts, program interrupts, instruction 
        and data storage interrupts, auxiliary processor unit (APU) interrupts, floating point unit (FPU 
        interrupts, TLB miss interrupts, system call interrupts, and alignment interrupts.
        Asynchronous precise interrupts include the critical and noncritical external interrupts, timer 
        facility interrupts, and some debug events.
        In the PPC405-S, machine checks are handled as critical interrupts.
        目前pippo的中断优先级，由高到低如下表所示
            1   Machine check - data; (Critical)
            2   Debug - IAC (Critical)
            3   Machine check - inst (Critical)
            4   Debug - EXC, UDE  (Critical)
            5   Critical interrupt input (Critical)
            6   Watchdog timer (Critical)
                     - first time-out
            7   Instruction TLB Miss (Noncritical)
            8   Instruction storage (Noncritical)
                    - ZPR[Zn] = 00          
            9   Instruction storage (Noncritical)
                    - TLB_entry[EX] = 0     
                Instruction storage (Noncritical)
                    - TLB_entry[G] = 1
                      or SGR[Gn] = 1
            10  Program (Noncritical)
                    Source: illegal/trap inst., privileged instruction in problem state, or APU/FPU...
                System Call (Noncritical)
                APU Unavailable (Noncritical)
                    Source: Attemped execution of an APU instruction when MSR[AP] = 0;
                FPU Unavailable (Noncritical)
                    Source: Attemped execution of an APU instruction when MSR[AP] = 0;
            11  Data TLB miss (Noncritical)
            12  Data storage (Noncritical)
                  - ZPR[Zn] = 00
            13  Data storage (Noncritical)
                  - TLB_entry[WR] = 0     
                Data storage (Noncritical)
                  - TLB_entry[U0] = 1
                    or SU0R[Un] = 1
            14  Alignment (Noncritical)
                    Source: dcbz to noncachable address or write-through storage; 
                            non-word aligned dcread, lwarx, and stwcx, as described 
                            in Table 4-10; misaligned APU or FPU data access
            15  Debug(Critical)
                  - BT, DAC, DVC, IC, TIE
            16  External interrupt input (Noncritical)
            17  Fixed Interval Timer(FIT) (Noncritical)
            18  Programmable Interval Timer(PIT) (Noncritical)                  
        关键和非关键中断
             非关键中断包括: data storage, instruction storage, an active external interrupt input, 
             alignment, program, FPU unavailable, APU unavailable, system call, programmable interval
             timer (PIT), fixed interval timer (FIT), data TLB miss, and instruction TLB miss. 
             关键中断包括：machine check interrupts (instruction- and data-side), debug interrupts, 
             interrupts caused by an active critical interrupt input, and the first time-out from 
             the watchdog timer.
        目前实现中断向量地址，根据中断类型列表如下：
            `define pippo_EXCEPT_CI 		`pippo_EXCEPT_WIDTH'h0100
            `define pippo_EXCEPT_CHK		`pippo_EXCEPT_WIDTH'h0200
            `define pippo_EXCEPT_DSI		`pippo_EXCEPT_WIDTH'h0300   // 暂未实现
            `define pippo_EXCEPT_ISI		`pippo_EXCEPT_WIDTH'h0400   // 暂未实现
            `define pippo_EXCEPT_EXT		`pippo_EXCEPT_WIDTH'h0500
            `define pippo_EXCEPT_ALIGN		`pippo_EXCEPT_WIDTH'h0600
            `define pippo_EXCEPT_PRG		`pippo_EXCEPT_WIDTH'h0700    
            `define pippo_EXCEPT_NOFPU     	`pippo_EXCEPT_WIDTH'h0800   // 暂未实现
            `define pippo_EXCEPT_SYSCALL	`pippo_EXCEPT_WIDTH'h0C00
            `define pippo_EXCEPT_NOAPU  	`pippo_EXCEPT_WIDTH'h0F20   // 暂未实现
            `define pippo_EXCEPT_PIT		`pippo_EXCEPT_WIDTH'h1000   
            `define pippo_EXCEPT_FIT		`pippo_EXCEPT_WIDTH'h1010   
            `define pippo_EXCEPT_WATCHDOG	`pippo_EXCEPT_WIDTH'h1020   
            `define pippo_EXCEPT_DTLBMISS	`pippo_EXCEPT_WIDTH'h1100   // 暂未实现
            `define pippo_EXCEPT_ITLBMISS	`pippo_EXCEPT_WIDTH'h1200   // 暂未实现
            `define pippo_EXCEPT_DEBUG  	`pippo_EXCEPT_WIDTH'h2000   // 暂未实现
        注意：pippo精确中断的实现－所有中断请求都在进入EXE/WB段后开始处理
        另外，内核为系统外部提供两个中断请求输入：其中一个用于critical interrupt，一个用于non-critical
        interrupt。注意PowerPC4xx系列内核包含内部timer和watchdog。MSR[CE]用于使能或关闭关键中断输入和
        watchdog首次超时中断；MSR[EE]用于使能或关闭非关键中断输入、PIT和FIT中断。     
    三，模块逻辑功能描述
        a）检测识别中断，当中断发生时刷新流水线，并根据优先级跳转至相关中断处理程序入口地址
        b）实现中断处理相关SPRs，以及和MSR的接口:
            Data Exception Address Register (DEAR)
            the Exception Vector Prefix Register (EVPR)
            Exception Syndrome Register (ESR)
            Machine Check Syndrome Register (MCSR)
            Save/Restore Registers (SRR0CSRR3)
        c）实现同步指令：
            context synchronization："isync, rfi, rfci, sc"; 
                rfi/rfci: 在中断FSM处于空闲时，检测rfi/rfci并进行svm检查，存在则刷新流水线一拍，更新msr，送出npc；
                isync: 类似rfi/rfci，区别是无须检测svm，npc为snia；
                sc: 按照正常中断处理，进入中断处理状态机；
            execution synchronization: "eieio, sync and mtmsr";
            storage synchronization: eieio, sync
        d）实现tw和twi指令，按照非调试使能产生program interrupt. 
            (SRR0) ←  address of tw instruction 
            (SRR1) ← (MSR) 
            (ESR[PTR]) ← 1 
            (MSR[WE, EE, PR, DR, IR]) ← 0 
            PC ←  EVPR0:15  || 0x0700
    四，FSM说明
        主要功能：            
            检测中断；
            根据中断类型，更新所有中断相关寄存器，包括MSR；其中也包含SPRs访问中断处理寄存器逻辑
            刷新流水线－从中断检测到进入处理程序时间为 拍；
        RTL规范
            状态EXP_Idle：空闲状态，系统复位后或上个中断处理完成返回的状态。
	            检测中断（flag_except信号）－对应相关指令的EXE段，如发生
	                except_detect信号将开始刷新流水线；
	                下一拍进入FLU1状态；	            
	            如无中断，保持Idle状态；
	            输出extend_flush为无效；
	        状态EXP_PROCESSING：中断识别
	            检测中断类型和优先级，开始中断的硬件处理
	                保存现场－写中断相关SPRs，并更新MSR；
	                送出npc_except和有效信号至取指部件
	            输出extend_flush为有效；
	            一拍之后进入FLU2状态；
	        状态EXP_DONE：中断完成状态；
                输出extend_flush为无效，结束刷新流水，一拍之后返回Idle状态；
                PC送出新的取指请求
 * Task.I: 
        [TBV] 同步指令等和外部中断同时有效的情况
        [TBV]异步中断请求须等待当前指令完成
                在异步请求到来后，立即stall住执行段，等待当前指令完成
                否则下一条指令会进入exe段，如引发高优先级中断，则异步中断得不到处理
        [TBD]新的取指请求必须在msr完成更新，建立新的context之后送出
        [TBD]嵌套中断和多个中断同时发生的情况处理逻辑   
            多个中断情况下，低优先级的中断如何处理？硬件还是软件完成？内部逻辑还是外部逻辑？
            CPU核内部能同时产生两个中断吗？例如总线错误，引发illegal指令等，待确认        
            to check if internal excepts are maskable.
            在masked情况下，中断请求是一直保持的吗？由外部逻辑保持还是内部逻辑保持
        [TBD] 
            在等待ISR返回第一条指令之时，如果发生外部中断请求？应该由软件屏蔽掉，否则这时流水线中的cia为无效值
            多中断情况处理
                正在处理中断（EXP_Processing状态时），外部高优先级请求到来，如何行为？现有逻辑是响应新的高优先级中断
                在EXE段存在多个中断请求时，一个内部和一个外部，如何保留低优先级的请求信号
                Core内部有可能同时出现两个需要处理的中断请求吗？sig_alian和sig_dbuserr
            现在pippo对非对齐访问的处理？ALIGN或者PRG－emulation非对齐访问指令？
            除buserr，还有其他machine check中断源？
            npc_except和npc_exp_valid时序
            FSM对刷新流水线有过强约束的嫌疑，待验证改进
            是否需要MSR的下一拍数据？
            Interrupt chaining是否需要硬件支持？
        [TBD] 对于两次写回指令的处理：现在拓展wb的方案，如果在写回完成一半时发生中断，如何处理？注意软件兼容性
        [TBV]中断相关SPRs的写操作（mtspr）和FSM状态没有关联
        [TBV]中断行为和现有ppc4xx系统软件的兼容性是一个很大的问题！涉及到总线行为，MSS和DSS系统
            现系统中断发生时机和现场－引发中断的指令在进入中断处理时的状态和处理完成后恢复等（开始执行还是部分完成等等）
 * Task.II
        [TBD] SPEC: When the TIEc405MmuEn signal is tied to 0, the TLB instructions (tlbia, tlbre, tlbsx, tlbsync, and 
              tlbwe) are treated as illegal instructions. 
 * Notes.Misc
        The interrupt response time in cycles has been improved from 26 cycles ARM7 required to switch from 
        processing to the beginning of the interrupt servicing routine, to 12 cycles in Cortex-M3...Lacking 
        a shadow register set, the interrupted context data including the program status register will be sent
        via a multiwrite instruction to a stack in memory, from which it will be recovered and restarted in 12
        cycles upon completion of the interrupt processing code. Interrupt chaining will fare even better: 
        instead of the 42 cycles ARM7 requires, Cortex-M3 will take only 6 cycles.[MPR]
 */ 
 
// synopsys translate_off
`include "timescale.v"
// synopsys translate_on
`include "def_pippo.v"

module pippo_except(

	clk, rst, 
	
	sig_dbuserr, sig_ibuserr, sig_ext_ci, sig_illegal, sig_emulate, sig_syscall, sig_align, sig_ext_i,
	sig_rfi, sig_rfci, 
    sig_eieio, sig_isync, sig_sync,
    sig_svm_check, sig_trap, 
	sig_pit, sig_fit, sig_watchdog,
	
	npc_except, npc_exp_valid, 
	
    ex_cia, ex_snia, 
    
	wb_freeze, asyn_stall, 
	
	flush_except,
	
    msr,
	msr_except, msr_expwe,
	
    eir,
    eir_we, ex_inst, 
	dear, esr, evpr, mcsr, srr0, srr1, srr2, srr3, 
	dear_we, esr_we, evpr_we, mcsr_we, srr0_we, srr1_we, srr2_we, srr3_we,
    spr_dat_i, 
				
	lsu_addr
);

//
// I/O
//
input				clk;
input				rst;                

// interrupt request
input				sig_dbuserr;
input				sig_ibuserr;
input				sig_ext_ci;
input				sig_illegal;
input				sig_syscall;
input				sig_align;
input				sig_ext_i;
input               sig_svm_check;
input               sig_trap;
// timer
input               sig_fit;
input		        sig_pit;
input               sig_watchdog;

// synchronization instruction
input               sig_eieio;
input               sig_isync;
input               sig_sync;

// emualtion request
input               sig_emulate;
    
// special case
input               sig_rfi;
input               sig_rfci;

// instruction and data pointer
input	[29:0]		ex_cia; 
input	[29:0]		ex_snia; 
input	[31:0]		lsu_addr;   

// pipelining control
input				wb_freeze;       
output              asyn_stall; 
output				flush_except; 
	
// MSR interface
input	[31:0]	msr;  
output	[31:0]	msr_except;
output          msr_expwe; 

// SPRs interface for mtspr inst.
input   dear_we;
input   esr_we;
input   evpr_we;
input   mcsr_we;
input   srr0_we;
input   srr1_we;
input   srr2_we;
input   srr3_we;


input	[31:0]		spr_dat_i; 

// SPRs interface for mfspr inst.
output	[31:0]		dear;
output	[31:0]		esr;
output	[31:0]		evpr;
output	[31:0]		mcsr;
output	[31:0]		srr0;
output	[31:0]		srr1;
output	[31:0]		srr2;
output	[31:0]		srr3;

// emulation
input   eir_we;
input   [31:0]      ex_inst;
output  [31:0]      eir;

// inst. fetch for exception
output	[31:0]      npc_except; 
output              npc_exp_valid; 

//
// Internal regs and wires
//
reg	[31:0]		dear;
reg	[31:0]		esr;
reg	[31:0]		evpr;
reg	[31:0]		mcsr;
reg	[31:0]		srr0;
reg	[31:0]		srr1;
reg	[31:0]		srr2;
reg	[31:0]		srr3;
reg	[31:0]		eir;

// FSM
reg [1:0]   state; 
reg [1:0]   state_next; 
reg         extend_flush;
reg         npc_exp_valid;
reg [31:0]  npc_except;
reg [15:0]  except_type;
reg         msr_expwe; 
reg [31:0]  msr_except;

reg	[31:0]		dear_new;
reg	[31:0]		esr_new;
reg	[31:0]		mcsr_new;
reg	[31:0]		srr0_new;
reg	[31:0]		srr1_new;
reg	[31:0]		srr2_new;
reg	[31:0]		srr3_new;
reg [31:0]      eir_new;

reg     [2:0]       delayed_ee;
reg     [2:0]       delayed_ce; 

//
// logic
//

// check svm for rfi/rfci inst.
assign rfi_go = sig_rfi & !msr[`pippo_MSR_PR_BITS];
assign rfci_go = sig_rfci & !msr[`pippo_MSR_PR_BITS];

// program interrupt
assign sig_prg = sig_illegal | sig_trap | sig_svm_check | 
                (sig_rfi & msr[`pippo_MSR_PR_BITS]) | (sig_rfci & msr[`pippo_MSR_PR_BITS]); 

//
// delayed_ee/delayed_ce
//
// MSR[CE]/MSR[EE] should not enable interrupts right away when 
// it is restored with rfi/rfci/wrtee/wrteei. Instead delayed_ee
// together with MSR[EE] enables interrupts once pipeline is 
// again ready.
//
always @(posedge rst or posedge clk)
	if (rst)
		delayed_ee <= #1 3'b000;
	else if (!msr[`pippo_MSR_EE_BITS])
		delayed_ee <= #1 3'b000;
	else
		delayed_ee <= #1 {delayed_ee[1:0], 1'b1};

always @(posedge rst or posedge clk)
	if (rst)
		delayed_ce <= #1 3'b000;
	else if (!msr[`pippo_MSR_CE_BITS])
		delayed_ce <= #1 3'b000;
	else
		delayed_ce <= #1 {delayed_ce[1:0], 1'b1};

//assign abort_ex = sig_dbuserr | sig_align | sig_prg;     // Abort write into RF by load & other instructions

//
// Spec: After detecting a critical interrupt, if no synchronous precise interrupts are outstanding, the 
//       PPC405-S immediately takes the critical interrupt and writes the address of the next instruction
//       to be executed in SRR2.
// Notes:
// 1. external non-critical and critical interrupt(asynchronous) must wait the completion of current instruction
// 2. delayed enable signals are for rfi/rfci processing
// [TBD] what about watchdog/fit/pit case, waiting the completion of current instruction?
//

// asyn_stall is forholding the execution stage, to prevent new instruction enter the execution stage
//      1, if wb_freeze assert, asyn_stall will asert for wb_freeze + 1 cycle
//      2, if wb_freeze disassert, it means current cycle is the write-back stage of current instructions
//         wb_done disassert, and will assert at next cycle if enable bit of msr is on
//         then, asycn_xxx_pending will assert
assign asyn_stall = (sig_ext_ci & msr[`pippo_MSR_CE_BITS] & delayed_ce[2]) |
                    (sig_ext_i & msr[`pippo_MSR_EE_BITS] & delayed_ee[2]) |
                    (sig_watchdog & msr[`pippo_MSR_CE_BITS] & delayed_ce[2]) |
                    (sig_fit & msr[`pippo_MSR_EE_BITS] & delayed_ee[2]) |
                    (sig_pit & msr[`pippo_MSR_EE_BITS] & delayed_ee[2]);

// when interrupt request assert, waiting the completion of current instruction
reg wb_done;          
always @(posedge rst or posedge clk) begin
	if (rst)
		wb_done <= #1 1'b0;
	else
		wb_done <= #1 !wb_freeze & ((msr[`pippo_MSR_CE_BITS] & (sig_ext_ci | sig_watchdog))
		             | (msr[`pippo_MSR_EE_BITS] & (sig_ext_i | sig_fit | sig_pit))); 
end

assign extci_pending = sig_ext_ci & msr[`pippo_MSR_CE_BITS] & delayed_ce[2]  & wb_done;
assign exti_pending = sig_ext_i & msr[`pippo_MSR_EE_BITS] & delayed_ee[2] & wb_done;
assign watchdog_pending = sig_watchdog & msr[`pippo_MSR_CE_BITS] & delayed_ce[2] & wb_done;
assign fit_pending = sig_fit & msr[`pippo_MSR_EE_BITS] & delayed_ee[2] & wb_done;
assign pit_pending = sig_pit & msr[`pippo_MSR_EE_BITS] & delayed_ee[2] & wb_done;

//
// Exception detection priority: msb > lsb
//
wire    [9:0]   except_trig; 
wire    [9:0]   except_rqt; 
reg     [9:0]   except_rqt_reg; 
assign except_rqt = {
			sig_dbuserr && msr[`pippo_MSR_ME_BITS],
	        sig_ibuserr && msr[`pippo_MSR_ME_BITS], 
            extci_pending,
            watchdog_pending,
            sig_prg, 
            sig_syscall, 
            sig_align, 
            exti_pending,
            fit_pending, 
            pit_pending
		};

// keep for one cycle for fsm
always @(posedge clk or posedge rst) begin
	if (rst)
		except_rqt_reg <= #1 10'b0;
	else 
		except_rqt_reg <= #1 except_rqt;
end

assign except_trig = except_rqt | except_rqt_reg; 

//
// Exception SPRs
//  [TBV] no need for pipeling control logic-wb_freeze to stop update
//        exception happen at mtspr's exe/wb cycle, flush will disenable spr_we
//

// dear: The DEAR is a 32-bit register that contains the address of the access 
//       for which one of the following synchronous precise errors occurred: 
//       alignment error, data TLB miss, or data storage interrupt.
always @(posedge clk or posedge rst) begin
	if (rst)
		dear <= #1 32'b0;
	else if(dear_we) 
		dear <= #1 spr_dat_i;
    else 
        dear <= #1 dear_new;
end

// esr: ESR[MCI]) bit behaves differently than others
always @(posedge clk or posedge rst) begin
	if (rst)
		esr <= #1 32'b0;
	else if(esr_we) 
		esr <= #1 spr_dat_i;
    else 
        esr <= #1 {sig_ibuserr | esr_new[31], esr_new[30:0]};
end

always @(posedge clk or posedge rst) begin
	if (rst)
		evpr <= #1 32'b0;
	else if(evpr_we) 
		evpr <= #1 spr_dat_i;
end

// Note: The MCSR bits are set, even if MSR[ME] = 0.
always @(posedge clk or posedge rst) begin
	if (rst) 
		mcsr <= #1 32'b0;
	else if(mcsr_we) 
		mcsr <= #1 spr_dat_i;
    else 
        mcsr <= #1 {sig_ibuserr | sig_dbuserr, sig_ibuserr, sig_dbuserr, 29'd0};
end

always @(posedge clk or posedge rst) begin
	if (rst) 
		srr0 <= #1 32'b0;
	else if(srr0_we) 
		srr0 <= #1 spr_dat_i;
    else 
        srr0 <= #1 srr0_new;
end

always @(posedge clk or posedge rst) begin
	if (rst) 
		srr1 <= #1 32'b0;
	else if(srr1_we) 
		srr1 <= #1 spr_dat_i;
    else 
        srr1 <= #1 srr1_new;
end

always @(posedge clk or posedge rst) begin
	if (rst) 
		srr2 <= #1 32'b0;
	else if(srr2_we) 
		srr2 <= #1 spr_dat_i;
    else 
        srr2 <= #1 srr2_new;
end

always @(posedge clk or posedge rst) begin
	if (rst)
		srr3 <= #1 32'b0;
	else if(srr3_we) 
		srr3 <= #1 spr_dat_i;
    else 
        srr3 <= #1 srr3_new;
end

// emualtion-specific register
always @(posedge clk or posedge rst) begin
	if (rst)
		eir <= #1 32'b0;
	else if(eir_we) 
		eir <= #1 spr_dat_i;
    else 
        eir <= #1 eir_new;
end
    
//
// FSM of flushing pipeline and switch to exception-handler
//
`define STATE_WIDTH     2
`define EXP_Idle	    `STATE_WIDTH'd0
`define EXP_Processing 	`STATE_WIDTH'd1
`define EXP_Done     	`STATE_WIDTH'd2

// assert for one cycle, at FSM state Idle            
assign flag_except = |except_trig & ~|state;       

// assert for two cycle for exception
// assert for one cycle for rfi/rfci/isync/emulate
assign flush_except = flag_except | extend_flush | rfi_go | rfci_go | sig_isync | sig_emulate;

always @(posedge clk or posedge rst) begin
	if (rst) begin
		state <= #1 `EXP_Idle;
	end
	else begin
        state <= #1 state_next;
    end
end
    
always @(state or except_trig or flag_except or except_type or rfi_go or rfci_go or sig_isync or
         ex_snia or ex_cia or lsu_addr or sig_illegal or sig_svm_check or sig_trap or sig_emulate or
         msr or esr or mcsr or dear or evpr or srr0 or srr1 or srr2 or srr3 or ex_inst or eir) begin
    state_next = `EXP_Idle; 
    npc_exp_valid = 1'b0; 
    npc_except = 32'd0; 
    extend_flush = 1'b0;
    except_type = `pippo_EXCEPT_NONE;

    msr_expwe = 1'b0; 
    msr_except = msr;
    dear_new = dear;
    esr_new = esr;
    mcsr_new = mcsr;
    srr0_new = srr0;
    srr1_new = srr1;
    srr2_new = srr2;
    srr3_new = srr3;
    eir_new = 32'd0;
    
    `ifdef pippo_CASE_DEFAULT
	case (state)	// synopsys parallel_case
    `else
	case (state)	// synopsys full_case parallel_case
    `endif

		`EXP_Idle: begin
		    extend_flush = 1'b0;
		    except_type = `pippo_EXCEPT_NONE;
		    case ({rfi_go, rfci_go, sig_isync, sig_emulate})		        

		        4'b1000: begin                  // rfi 
			        npc_exp_valid = 1'b1;  
			        npc_except = srr0;
			        msr_expwe = 1'b1; 
			        msr_except = srr1;
		        end

		        4'b0100: begin                  // rfci
			        npc_exp_valid = 1'b1;
			        npc_except = srr2; 			        			        
			        msr_expwe = 1'b1; 
			        msr_except = srr3;
		        end
		        
		        4'b0010: begin                  // isync
			        npc_exp_valid = 1'b1;  
			        npc_except = {ex_snia, 2'b00};
			        msr_expwe = 1'b1; 
			        msr_except = msr;			
		        end
		        
		        4'b0001: begin                  // emulation
			        npc_exp_valid = 1'b1;  
			        npc_except = `pippo_EMU_ROMADDR;
			        msr_expwe = 1'b1; 
                    msr_except = 32'd0;
                    srr0_new = {ex_snia, 2'b00};
                    srr1_new = msr;
                    eir_new = ex_inst; 
		        end

		        default: begin
			        npc_exp_valid = 1'b0;
			        npc_except = 32'd0;
			        msr_expwe = 1'b0; 
			        msr_except = msr;
                    srr0_new = srr0;
                    srr1_new = srr1;
                    eir_new = eir; 
		        end
            endcase
            			        			                                			
            // "~msr_expwe": for rfi/rfci/isync/emulate processing, delayed exception
			if (flag_except & ~msr_expwe) begin     
				state_next = `EXP_Processing;
			end	
			else begin
			    state_next = `EXP_Idle;
			end
        end
			
		`EXP_Processing: begin
			state_next = `EXP_Done;
			extend_flush = 1'b1;
			casex (except_trig)

                `ifdef pippo_EXCEPT_CHK         // Data-side machine check
				10'b1x_xxxx_xxxx: begin
					except_type = `pippo_EXCEPT_CHK;
                    msr_expwe = 1'b1; 
                    msr_except = 32'd0;
                    srr2_new = {ex_snia, 2'b00};
                    srr3_new = msr;
				end
                `endif

                `ifdef pippo_EXCEPT_CHK         // Inst.-side machine check
				10'b01_xxxx_xxxx: begin
					except_type = `pippo_EXCEPT_CHK;
                    msr_expwe = 1'b1; 
                    msr_except = 32'd0;
                    esr_new = {1'b1, 31'd0};
                    srr2_new = {ex_cia, 2'b00};
                    srr3_new = msr;
				end
                `endif

                `ifdef pippo_EXCEPT_CI          // external critical interrupt
                10'b00_1xxx_xxxx: begin                    
					except_type = `pippo_EXCEPT_CI;
                    msr_expwe = 1'b1; 
                    msr_except = {19'd0, msr[`pippo_MSR_ME_BITS], 12'd0};
                    srr2_new = {ex_snia, 2'b00};      
                    srr3_new = msr;
                end
                `endif

                `ifdef pippo_EXCEPT_WATCHDOG    // watchdog interrupt
                10'b00_01xx_xxxx: begin          
                    except_type = `pippo_EXCEPT_WATCHDOG;
                    msr_expwe = 1'b1; 
                    msr_except = {19'd0, msr[12], 12'd0};   // ME unchanged
                    srr0_new = {ex_snia, 2'b00};     
                    srr1_new = msr;                                                   
                end
                `endif

                `ifdef pippo_EXCEPT_PRG         // program interrupt: illegal, svm, trap, unimpl...
                10'b00_001x_xxxx: begin                    
					except_type = `pippo_EXCEPT_PRG;
                    msr_expwe = 1'b1; 
                    msr_except = {14'd0, msr[17], 4'd0, msr[12], 2'd0, msr[9], 9'd0};   // CE, ME, DE unchanged
                    srr0_new = {ex_cia, 2'b00};
                    srr1_new = msr;
                    esr_new = {4'd0, sig_illegal, sig_svm_check, sig_trap, 1'b0, 24'd0};    // apu/fpu is off currently
                end
                `endif
                
                `ifdef pippo_EXCEPT_SYSCALL     //syscall
                10'b00_0001_xxxx: begin                    
					except_type = `pippo_EXCEPT_SYSCALL;
                    msr_expwe = 1'b1; 
                    msr_except = {14'd0, msr[17], 4'd0, msr[12], 2'd0, msr[9], 9'd0};   // CE, ME, DE unchanged
                    srr0_new = {ex_snia, 2'b00};
                    srr1_new = msr;
                end                    
                `endif
                
                `ifdef pippo_EXCEPT_ALIGN   // align interrupt - [TBD] move normal load/store align to another vector
                10'b00_0000_1xxx: begin                    
					except_type = `pippo_EXCEPT_ALIGN;
                    msr_expwe = 1'b1; 
                    msr_except = {14'd0, msr[17], 4'd0, msr[12], 2'd0, msr[9], 9'd0};   // CE, ME, DE unchanged
                    dear_new = lsu_addr;
                    srr0_new = {ex_cia, 2'b00};
                    srr1_new = msr;
                end                    
                `endif

                `ifdef pippo_EXCEPT_EXT     // external non-critical interrupt
                10'b00_0001_01xx: begin                    
					except_type = `pippo_EXCEPT_EXT;
                    msr_expwe = 1'b1; 
                    msr_except = {14'd0, msr[17], 4'd0, msr[12], 2'd0, msr[9], 9'd0};   // CE, ME, DE unchanged
                    srr0_new = {ex_snia, 2'b00}; 
                    srr1_new = msr;
                end                    
                `endif

                `ifdef pippo_EXCEPT_FIT    // fit interrupt
                10'b00_0000_001x: begin                    
                    except_type = `pippo_EXCEPT_FIT;
                    msr_expwe = 1'b1; 
                    msr_except = {14'd0, msr[17], 4'd0, msr[12], 2'd0, msr[9], 9'd0};   // CE, ME, DE unchanged
                    srr0_new = {ex_snia, 2'b00};  
                    srr1_new = msr;                         
                end
                `endif

                `ifdef pippo_EXCEPT_PIT    // to ask software guy, why snia(PowerPC SPEC)?
                10'b00_0000_0001: begin           
                    except_type = `pippo_EXCEPT_PIT;
                    msr_expwe = 1'b1; 
                    msr_except = {14'd0, msr[17], 4'd0, msr[12], 2'd0, msr[9], 9'd0};   // CE, ME, DE unchanged
                    srr0_new = {ex_snia, 2'b00}; 
                    srr1_new = msr;                         
                end
                `endif

                default: begin
                    except_type = `pippo_EXCEPT_NONE;
                    msr_expwe = 1'b0; 
                    msr_except = msr;
                    dear_new = dear;
                    esr_new = esr;
                    mcsr_new = mcsr;
                    srr0_new = srr0;
                    srr1_new = srr1;
                    srr2_new = srr2;
                    srr3_new = srr3;
                end						                
			endcase

			npc_exp_valid = 1'b1; 
            npc_except = {evpr[31:16], except_type};    // notes: the order of assignmen-except must behind type.
                                                        // or wrong logic will be inferred by syn and sim tools
        end
					
		`EXP_Done: begin
            extend_flush = 1'b0;
            except_type = `pippo_EXCEPT_NONE;
            npc_exp_valid = 1'b0; 
            state_next = `EXP_Idle;
        end
    endcase
end

endmodule
